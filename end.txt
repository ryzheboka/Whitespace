
atoi:
	  mov       rcx, r8
	  add       rcx, 6                  ; set the maximum adress for a char
	  mov       r10, 0                  ; initialize int value
          cmp       byte[r8],45
          je        atoi.neg_beg
	  jmp       atoi.if

.if:
          cmp       r8,rcx                  ; compare the address of cur char with end address
          jne       atoi.if2
          mov       rax, input
          cmp       byte[rax],45
          je        atoi.neg_end
          ret

.if2:
          movzx     r9,byte[r8]	            ; "read" current char into r9
          cmp       r9,48
          jge       .if3
          mov       rax, input
          cmp       byte[rax],45
          je        atoi.neg_end
          ret
.if3:
          movzx     r9,byte[r8]	            ; "read" current char into r9
          cmp       r9,57
          jle       .if4
          mov       rax, input
          cmp       byte[rax],45
          je        atoi.neg_end
          ret

.if4:
          sub       r9,48
          mov       rax,10
          mul       r10
          mov       r10,rax
          add       r10,r9
          inc       r8
          jmp       .if
.neg_beg:
          inc       r8
          jmp       atoi.if
.neg_end:
          neg       r10
          ret

itoa:  ;int needs to be stored in r10
          mov       r8, output              ;
          add       r8, 5                   ; set the r8 pointer to the end
          mov       rcx, output             ; load begging address for comparison
          mov       r9, 10                  ; load ten for division
          cmp       r10,0                   ; if value is negative, jump
          jl        itoa.neg
          jmp       itoa.loop

.loop:
          mov       rdx, 0                  ; set rdx to 0 as division concatenates rdx and rax
          mov       rax,r10                 ; move value into rax to divide it later
          div       r9                      ; divide the value in rax by ten
          add       rdx, 48                 ; make a character from the int-remainder in rdx
          mov       [r8],dl                 ; write this character to the address given by the pointer
          dec       r8                      ; decrease pointer, so next char will be written earlier
          cmp       r10, r9                 ; if value <10 jump out of loop
          jae       itoa.loop_end           ;
          ret

.loop_end:
          mov       r10, rax                ; move the quotient into r10
          jmp       itoa.loop               ; jump to begin of loop

.neg:
          mov       rax,45
          mov       [rcx],rax                ; set first char to "-"
          inc       rcx                      ; set addr of second char as first char
          neg       r10                      ; create abs value
          jmp       itoa.loop
store: ; addr in r8, val in r9
          mov       rax,addrs
          mov       rcx,r8
          mov       [rax+r11],ecx
          mov       rcx,r9
          mov       rax,vals
          mov       [rax+r11],ecx
          add       r11,4
          ret
read: ;init rdx before
          mov       rax,addrs
          mov       rcx,r8
          cmp       dword [rax+rdx],ecx
          je        .read_val
          add       rdx,4
          cmp       rdx,49
          jl        read
          ret

.read_val:
          mov       rax,vals
          movsx     r10, dword [rax+rdx]
          ret


          section   .bss
input:    resb      16
output:   resb      6
addrs:    resb      50                       ; contains virtual heap addresses from .ws
vals:     resb      50                       ; contains corresponding (to addresses from addrs) values